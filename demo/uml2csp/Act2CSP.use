model Act2CSP
class ActivityEdge
attributes
  name : String
  guard : String
end

class Action < ActivityNode
attributes
  name : String
end

class ActivityNode
end

class DecisionNode < ActivityNode
end

class ForkNode < ActivityNode
end

class FinalNode < ActivityNode
end

class InitialNode < ActivityNode
end

class JoinNode < ActivityNode
end

class MergeNode < ActivityNode
end


association ConnectsFrom between
  ActivityEdge[0..*] role outEdge
  ActivityNode[0..1] role source
end
association ConnectsTo between
  ActivityEdge[0..*] role inEdge
  ActivityNode[0..1] role target
end

constraints

-- invariants on UML activity diagrams
context InitialNode inv oneInitialNode:
  InitialNode.allInstances->size()=1
context InitialNode inv hasOutgoingEdge:
  outEdge->size()>0
context FinalNode inv hasIncomingEdge:
  inEdge->size()>0
context DecisionNode inv hasAtLeastTwoOutgoingEdges:
  outEdge->size()>=2
context DecisionNode inv hasDifferentGuardsOnOutgoingEdges:
  outEdge->forAll(e1,e2|e1<>e2 implies e1.guard<>e2.guard)


class ProcessExpression
end

class BinaryOperator < ProcessExpression
end

class Condition < BinaryOperator
attributes
  expression : String
end

class Concurrency < BinaryOperator,ProcessWithSet
attributes
  name : String
end

class Process < ProcessExpression
attributes
  name : String
  subscript : String
end

class CspContainer
end

class ProcessAssignment
end

class Prefix < ProcessExpression
end

class ProcessWithSet < ProcessExpression
end

class Hiding < ProcessWithSet
end

class Event
attributes
  name : String
end

association Hides between
  Hiding[0..1] role hiding
  ProcessExpression[1..1] role processExpression
end
association References between
  ProcessWithSet[0..1] role processWithSet
  Event[0..*] role event
end
association Becomes between
  Prefix[0..*] role prefix
  ProcessExpression[1..1] role processExpression
end
association Performs between
  Prefix[0..*] role prefix
  Event[1..1] role event
end
association AssignsRight between
  ProcessAssignment[0..*] role process
  ProcessExpression[1..1] role right
end
association AssignsLeft between
  ProcessAssignment[0..1] role processIdentifier
  Process[1..1] role left
end
association ContainsProcessAssignment between
  CspContainer[0..1] role cspContainer
  ProcessAssignment[0..*] role processAssignment
end
association CombinesLeft between
  BinaryOperator[0..1] role binaryOperatorLeft
  ProcessExpression[1..1] role leftHandSide
end
association CombinesRight between
  BinaryOperator[0..1] role binaryOperatorRight
  ProcessExpression[1..1] role rightHandSide
end

constraints

-- invariants on CSP processes
context Hiding inv hiddenEventsNotEmpty:
  event->notEmpty()
context BinaryOperator inv LhsUnequalRhs:
  leftHandSide<>rightHandSide
context CspContainer inv distinctProcessNames:
  processAssignment->forAll(pa1,pa2|pa1<>pa2 implies pa1.left.name<>pa2.left.name)


class AC2E
end

class AE2CON
end

class AE2P
end

class F2P
end
association Action_AC2E between
    Action[1] role act
    AC2E[*] role cp_Action_AC2E
end
association ActivityEdge_AE2CON between
    ActivityEdge[1] role ae
    AE2CON[*] role cp_ActivityEdge_AE2CON
end
association ActivityEdge_AE2P between
    ActivityEdge[1] role ae
    AE2P[*] role cp_ActivityEdge_AE2P
end
association Condition_AE2CON between
    Condition[1] role con
    AE2CON[*] role cp_Condition_AE2CON
end
association Event_AC2E between
    Event[1] role event
    AC2E[*] role cp_Event_AC2E
end
association FinalNode_F2P between
    FinalNode[1] role f
    F2P[*] role cp_FinalNode_F2P
end
association Process_AE2P between
    Process[1] role p
    AE2P[*] role cp_Process_AE2P
end
association Process_F2P between
    Process[1] role p
    F2P[*] role cp_Process_F2P
end

-- Invariants for Correspondence classes
constraints
context AC2E inv: self.event.name=self.act.name
context AE2CON inv: self.con.expression=self.ae.guard
context AE2P inv: self.p.name=self.ae.name
class RuleCollection
------------------------------------------------------------Operations
operations
------------------------------Co-Evolution operations
  trafoActionNode_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,_action_name:String),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoDecision2Node_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoDecision3Node_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String,_theActivityEdgeC_name:String),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoFinalNode_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge),
    matchCL:Tuple(ae2p:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoForkNode_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,_theActivityEdgeD_name:String),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoInitialNode_coEvol(
    matchSL:Tuple(_theActivityEdgeA_name:String)  )

  trafoJoinNode_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,_theActivityEdgeD_name:String),
    matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
    matchTL:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)  )

  trafoMergeNode_coEvol(
    matchSL:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,_theActivityEdgeC_name:String),
    matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
    matchTL:Tuple(theProcessA:Process,theProcessB:Process)  )

------------------------------Forward transformation operation
  trafoActionNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,action:Action,theActivityEdgeB:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoDecision2Node_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoDecision3Node_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoFinalNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,finalNode:FinalNode),
    matchCL:Tuple(ae2p:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoForkNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,forkNode:ForkNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTL:Tuple(theProcessA:Process)  )

  trafoInitialNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,init:InitialNode)  )

  trafoJoinNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,joinNode:JoinNode,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
    matchTL:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)  )

  trafoMergeNode_forwTrafo(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,mergeNode:MergeNode),
    matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
    matchTL:Tuple(theProcessA:Process,theProcessB:Process)  )

------------------------------Integration operation
  trafoActionNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,action:Action,theActivityEdgeB:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,prefix:Prefix,theProcessB:Process,theEvent:Event)  )

  trafoDecision2Node_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,condition1:Condition,theProcessB:Process,theProcessC:Process)  )

  trafoDecision3Node_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,condition1:Condition,condition2:Condition,theProcessB:Process,theProcessC:Process,theProcessD:Process)  )

  trafoFinalNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,finalNode:FinalNode),
    matchCL:Tuple(ae2p:AE2P),
    matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,SKIP:Process)  )

  trafoForkNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,forkNode:ForkNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P),
    matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,concurrency1:Concurrency,concurrency2:Concurrency,theProcessB:Process,theProcessC:Process,theProcessD:Process)  )

  trafoInitialNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,init:InitialNode),
    matchTR:Tuple(theProcessA:Process)  )

  trafoJoinNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,joinNode:JoinNode,theActivityEdgeD:ActivityEdge),
    matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
    matchTR:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,assignment3:ProcessAssignment,prefix1:Prefix,prefix2:Prefix,prefix3:Prefix,processJoin:Event,SKIP:Process,theProcessD:Process)  )

  trafoMergeNode_integration(
    matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,mergeNode:MergeNode),
    matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
    matchTR:Tuple(theProcessA:Process,theProcessB:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,theProcessC:Process)  )

end
------------------------------------------------------------Pre, post-conditions

constraints
------------------------------Co-Evolution

context RuleCollection::trafoActionNode_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,_action_name:String),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoActionNode_coEvol_pre:
--------------------
--matchSL : Tuple(_action_name:String,theActivityEdgeA:ActivityEdge)
  let _action_name:String = matchSL._action_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoActionNode_coEvol_post:
--------------------
--matchSL : Tuple(_action_name:String,theActivityEdgeA:ActivityEdge)
  let _action_name:String = matchSL._action_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA}) and
  (Action.allInstances - Action.allInstances@pre)->exists(action|
    (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeB|
      action.inEdge->includesAll(Set{theActivityEdgeA}) and
      action.outEdge->includesAll(Set{theActivityEdgeB}) and
      action.name<>oclUndefined(String) and
      theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
      action.cp_Action_AC2E->size()=0 and
      --T_postcondition
      Process.allInstances->includesAll(Set{theProcessA}) and
      (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
        (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix|
          (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
            (Event.allInstances - Event.allInstances@pre)->exists(theEvent|
              assignment.left->includesAll(Set{theProcessA}) and
              prefix.process->includesAll(Set{assignment}) and
              theEvent.prefix->includesAll(Set{prefix}) and
              theProcessB.prefix->includesAll(Set{prefix}) and
              --C_postcondition
              AE2P.allInstances->includesAll(Set{ae2p1}) and
              (AC2E.allInstances - AC2E.allInstances@pre)->exists(ac2e|
                (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                  theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                  theEvent.cp_Event_AC2E->includesAll(Set{ac2e}) and
                  action.cp_Action_AC2E->includesAll(Set{ac2e}) and
                  theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                  ac2e.event.name=ac2e.act.name and
                  ae2p2.p.name=ae2p2.ae.name
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoDecision2Node_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoDecision2Node_coEvol_pre:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision2Node_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA}) and
  (DecisionNode.allInstances - DecisionNode.allInstances@pre)->exists(decisionNode|
    (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeB|
      (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeC|
        decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
        decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
        decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
        theActivityEdgeB.name<>oclUndefined(String) and
        theActivityEdgeC.guard = 'else' and
        decisionNode.outEdge->size()=2 and
        theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
        theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
        --T_postcondition
        Process.allInstances->includesAll(Set{theProcessA}) and
        (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
          (Condition.allInstances - Condition.allInstances@pre)->exists(condition1|
            (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
              (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
                assignment.left->includesAll(Set{theProcessA}) and
                condition1.process->includesAll(Set{assignment}) and
                condition1.leftHandSide->includesAll(Set{theProcessB}) and
                condition1.rightHandSide->includesAll(Set{theProcessC}) and
                --C_postcondition
                AE2P.allInstances->includesAll(Set{ae2p1}) and
                (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
                  (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
                    (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                      theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                      theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                      theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                      condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
                      theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                      theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
                      ae2p3.p.name=ae2p3.ae.name and
                      ae2con1.con.expression=ae2con1.ae.guard and
                      ae2p2.p.name=ae2p2.ae.name
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoDecision3Node_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String,_theActivityEdgeC_name:String),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoDecision3Node_coEvol_pre:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision3Node_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA}) and
  (DecisionNode.allInstances - DecisionNode.allInstances@pre)->exists(decisionNode|
    (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeB|
      (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeC|
        (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeD|
          decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
          decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
          decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
          decisionNode.outEdge->includesAll(Set{theActivityEdgeD}) and
          theActivityEdgeB.name<>oclUndefined(String) and
          theActivityEdgeC.name<>oclUndefined(String) and
          theActivityEdgeD.guard = 'else' and
          decisionNode.outEdge->size()=3 and
          theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
          theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
          theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
          --T_postcondition
          Process.allInstances->includesAll(Set{theProcessA}) and
          (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
            (Condition.allInstances - Condition.allInstances@pre)->exists(condition1|
              (Condition.allInstances - Condition.allInstances@pre)->exists(condition2|
                (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
                  (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
                    (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
                      assignment.left->includesAll(Set{theProcessA}) and
                      condition1.process->includesAll(Set{assignment}) and
                      condition1.leftHandSide->includesAll(Set{theProcessB}) and
                      condition1.rightHandSide->includesAll(Set{condition2}) and
                      condition2.leftHandSide->includesAll(Set{theProcessC}) and
                      condition2.rightHandSide->includesAll(Set{theProcessD}) and
                      --C_postcondition
                      AE2P.allInstances->includesAll(Set{ae2p1}) and
                      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
                        (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
                          (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                            (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con2|
                              (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                                theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                                theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                                theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                                theActivityEdgeC.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con2}) and
                                theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                                theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                                condition2.cp_Condition_AE2CON->includesAll(Set{ae2con2}) and
                                condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
                                theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                                theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
                                ae2p3.p.name=ae2p3.ae.name and
                                ae2con1.con.expression=ae2con1.ae.guard and
                                ae2p2.p.name=ae2p2.ae.name and
                                ae2con2.con.expression=ae2con2.ae.guard and
                                ae2p4.p.name=ae2p4.ae.name
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoFinalNode_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge),
  matchCL:Tuple(ae2p:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoFinalNode_coEvol_pre:
--------------------
--matchSL : Tuple(theActivityEdgeA:ActivityEdge)
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and    
    ae2p.p.name=ae2p.ae.name

post trafoFinalNode_coEvol_post:
--------------------
--matchSL : Tuple(theActivityEdgeA:ActivityEdge)
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA}) and
  (FinalNode.allInstances - FinalNode.allInstances@pre)->exists(finalNode|
    finalNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    finalNode.cp_FinalNode_F2P->size()=0 and
    --T_postcondition
    Process.allInstances->includesAll(Set{theProcessA}) and
    (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
      (Process.allInstances - Process.allInstances@pre)->exists(SKIP|
        SKIP.process->includesAll(Set{assignment}) and
        assignment.left->includesAll(Set{theProcessA}) and
        SKIP.name = 'SKIP' and
        --C_postcondition
        AE2P.allInstances->includesAll(Set{ae2p}) and
        (F2P.allInstances - F2P.allInstances@pre)->exists(f2p|
          SKIP.cp_Process_F2P->includesAll(Set{f2p}) and
          finalNode.cp_FinalNode_F2P->includesAll(Set{f2p})
        )
      )
    )
  )

context RuleCollection::trafoForkNode_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,_theActivityEdgeD_name:String),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoForkNode_coEvol_pre:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,_theActivityEdgeD_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let _theActivityEdgeD_name:String = matchSL._theActivityEdgeD_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoForkNode_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeB_name:String,_theActivityEdgeC_name:String,_theActivityEdgeD_name:String,theActivityEdgeA:ActivityEdge)
  let _theActivityEdgeB_name:String = matchSL._theActivityEdgeB_name in
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let _theActivityEdgeD_name:String = matchSL._theActivityEdgeD_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA}) and
  (ForkNode.allInstances - ForkNode.allInstances@pre)->exists(forkNode|
    (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeB|
      (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeC|
        (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeD|
          forkNode.inEdge->includesAll(Set{theActivityEdgeA}) and
          forkNode.outEdge->includesAll(Set{theActivityEdgeB}) and
          forkNode.outEdge->includesAll(Set{theActivityEdgeC}) and
          forkNode.outEdge->includesAll(Set{theActivityEdgeD}) and
          theActivityEdgeB.name<>oclUndefined(String) and
          theActivityEdgeC.name<>oclUndefined(String) and
          theActivityEdgeD.name<>oclUndefined(String) and
          theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
          theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
          theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
          --T_postcondition
          Process.allInstances->includesAll(Set{theProcessA}) and
          (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
            (Concurrency.allInstances - Concurrency.allInstances@pre)->exists(concurrency1|
              (Concurrency.allInstances - Concurrency.allInstances@pre)->exists(concurrency2|
                (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
                  (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
                    (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
                      assignment.left->includesAll(Set{theProcessA}) and
                      concurrency1.process->includesAll(Set{assignment}) and
                      concurrency1.leftHandSide->includesAll(Set{theProcessB}) and
                      concurrency1.rightHandSide->includesAll(Set{concurrency2}) and
                      concurrency2.leftHandSide->includesAll(Set{theProcessC}) and
                      concurrency2.rightHandSide->includesAll(Set{theProcessD}) and
                      --C_postcondition
                      AE2P.allInstances->includesAll(Set{ae2p1}) and
                      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
                        (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                          (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                            theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                            theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                            theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                            theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                            theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                            theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                            ae2p3.p.name=ae2p3.ae.name and
                            ae2p2.p.name=ae2p2.ae.name and
                            ae2p4.p.name=ae2p4.ae.name
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoInitialNode_coEvol(
  matchSL:Tuple(_theActivityEdgeA_name:String))


post trafoInitialNode_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeA_name:String)
  let _theActivityEdgeA_name:String = matchSL._theActivityEdgeA_name in
  --S_postcondition
  (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeA|
    (InitialNode.allInstances - InitialNode.allInstances@pre)->exists(init|
      init.outEdge->includesAll(Set{theActivityEdgeA}) and
      theActivityEdgeA.name<>oclUndefined(String) and
      theActivityEdgeA.cp_ActivityEdge_AE2P->size()=0 and
      --T_postcondition
      (Process.allInstances - Process.allInstances@pre)->exists(theProcessA|
        --C_postcondition
        (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p|
          theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
          theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and
          ae2p.p.name=ae2p.ae.name
        )
      )
    )
  )

context RuleCollection::trafoJoinNode_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,_theActivityEdgeD_name:String),
  matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
  matchTL:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process))

pre trafoJoinNode_coEvol_pre:
--------------------
--matchSL : Tuple(_theActivityEdgeD_name:String,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let _theActivityEdgeD_name:String = matchSL._theActivityEdgeD_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSL.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSL.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  let theProcessC:Process = matchTL.theProcessC in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p3.p.name=ae2p3.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoJoinNode_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeD_name:String,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let _theActivityEdgeD_name:String = matchSL._theActivityEdgeD_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSL.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSL.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  let theProcessC:Process = matchTL.theProcessC in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA,theActivityEdgeB,theActivityEdgeC}) and
  (JoinNode.allInstances - JoinNode.allInstances@pre)->exists(joinNode|
    (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeD|
      joinNode.inEdge->includesAll(Set{theActivityEdgeA}) and
      joinNode.inEdge->includesAll(Set{theActivityEdgeB}) and
      joinNode.inEdge->includesAll(Set{theActivityEdgeC}) and
      joinNode.outEdge->includesAll(Set{theActivityEdgeD}) and
      theActivityEdgeD.name<>oclUndefined(String) and
      theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
      --T_postcondition
      Process.allInstances->includesAll(Set{theProcessA,theProcessB,theProcessC}) and
      (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment1|
        (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment2|
          (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment3|
            (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix1|
              (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix2|
                (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix3|
                  (Event.allInstances - Event.allInstances@pre)->exists(processJoin|
                    (Process.allInstances - Process.allInstances@pre)->exists(SKIP|
                      (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
                        assignment1.left->includesAll(Set{theProcessA}) and
                        prefix1.process->includesAll(Set{assignment1}) and
                        assignment2.left->includesAll(Set{theProcessB}) and
                        prefix2.process->includesAll(Set{assignment2}) and
                        assignment3.left->includesAll(Set{theProcessC}) and
                        prefix3.process->includesAll(Set{assignment3}) and
                        processJoin.prefix->includesAll(Set{prefix1}) and
                        theProcessD.prefix->includesAll(Set{prefix1}) and
                        processJoin.prefix->includesAll(Set{prefix2}) and
                        SKIP.prefix->includesAll(Set{prefix2}) and
                        processJoin.prefix->includesAll(Set{prefix3}) and
                        SKIP.prefix->includesAll(Set{prefix3}) and
                        SKIP.name='SKIP' and
                        processJoin.name='processJoin' and
                        --C_postcondition
                        AE2P.allInstances->includesAll(Set{ae2p1,ae2p3,ae2p2}) and
                        (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                          theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                          theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                          ae2p4.p.name=ae2p4.ae.name
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoMergeNode_coEvol(
  matchSL:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,_theActivityEdgeC_name:String),
  matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
  matchTL:Tuple(theProcessA:Process,theProcessB:Process))

pre trafoMergeNode_coEvol_pre:
--------------------
--matchSL : Tuple(_theActivityEdgeC_name:String,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSL.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
    --S_precondition
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String) and
    --T_precondition and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoMergeNode_coEvol_post:
--------------------
--matchSL : Tuple(_theActivityEdgeC_name:String,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let _theActivityEdgeC_name:String = matchSL._theActivityEdgeC_name in
  let theActivityEdgeA:ActivityEdge = matchSL.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSL.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  --S_postcondition
  ActivityEdge.allInstances->includesAll(Set{theActivityEdgeA,theActivityEdgeB}) and
  (ActivityEdge.allInstances - ActivityEdge.allInstances@pre)->exists(theActivityEdgeC|
    (MergeNode.allInstances - MergeNode.allInstances@pre)->exists(mergeNode|
      mergeNode.inEdge->includesAll(Set{theActivityEdgeA}) and
      mergeNode.inEdge->includesAll(Set{theActivityEdgeB}) and
      mergeNode.outEdge->includesAll(Set{theActivityEdgeC}) and
      theActivityEdgeC.name<>oclUndefined(String) and
      theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
      --T_postcondition
      Process.allInstances->includesAll(Set{theProcessA,theProcessB}) and
      (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment1|
        (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment2|
          (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
            assignment1.left->includesAll(Set{theProcessA}) and
            theProcessC.process->includesAll(Set{assignment1}) and
            assignment2.left->includesAll(Set{theProcessB}) and
            theProcessC.process->includesAll(Set{assignment2}) and
            --C_postcondition
            AE2P.allInstances->includesAll(Set{ae2p1,ae2p2}) and
            (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
              theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
              theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
              ae2p3.p.name=ae2p3.ae.name
            )
          )
        )
      )
    )
  )

--------------------------------------------------Forward transformation

context RuleCollection::trafoActionNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,action:Action,theActivityEdgeB:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoActionNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(action:Action,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let action:Action = matchSR.action in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    action.inEdge->includesAll(Set{theActivityEdgeA}) and
    action.outEdge->includesAll(Set{theActivityEdgeB}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    action.name<>oclUndefined(String) and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    action.cp_Action_AC2E->size()=0 and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoActionNode_forwTrafo_post:
--------------------
--matchSR : Tuple(action:Action,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let action:Action = matchSR.action in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
    (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix|
      (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
        (Event.allInstances - Event.allInstances@pre)->exists(theEvent|
          assignment.left->includesAll(Set{theProcessA}) and
          prefix.process->includesAll(Set{assignment}) and
          theEvent.prefix->includesAll(Set{prefix}) and
          theProcessB.prefix->includesAll(Set{prefix}) and
          --C_postcondition
          AE2P.allInstances->includesAll(Set{ae2p1}) and
          (AC2E.allInstances - AC2E.allInstances@pre)->exists(ac2e|
            (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
              theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
              theEvent.cp_Event_AC2E->includesAll(Set{ac2e}) and
              action.cp_Action_AC2E->includesAll(Set{ac2e}) and
              theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
              ac2e.event.name=ac2e.act.name and
              ae2p2.p.name=ae2p2.ae.name
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoDecision2Node_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoDecision2Node_forwTrafo_pre:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.guard = 'else' and
    decisionNode.outEdge->size()=2 and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision2Node_forwTrafo_post:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
    (Condition.allInstances - Condition.allInstances@pre)->exists(condition1|
      (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
        (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
          assignment.left->includesAll(Set{theProcessA}) and
          condition1.process->includesAll(Set{assignment}) and
          condition1.leftHandSide->includesAll(Set{theProcessB}) and
          condition1.rightHandSide->includesAll(Set{theProcessC}) and
          --C_postcondition
          AE2P.allInstances->includesAll(Set{ae2p1}) and
          (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
            (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
              (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
                theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
                ae2p3.p.name=ae2p3.ae.name and
                ae2con1.con.expression=ae2con1.ae.guard and
                ae2p2.p.name=ae2p2.ae.name
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoDecision3Node_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoDecision3Node_forwTrafo_pre:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeD.guard = 'else' and
    decisionNode.outEdge->size()=3 and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision3Node_forwTrafo_post:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
    (Condition.allInstances - Condition.allInstances@pre)->exists(condition1|
      (Condition.allInstances - Condition.allInstances@pre)->exists(condition2|
        (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
          (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
            (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
              assignment.left->includesAll(Set{theProcessA}) and
              condition1.process->includesAll(Set{assignment}) and
              condition1.leftHandSide->includesAll(Set{theProcessB}) and
              condition1.rightHandSide->includesAll(Set{condition2}) and
              condition2.leftHandSide->includesAll(Set{theProcessC}) and
              condition2.rightHandSide->includesAll(Set{theProcessD}) and
              --C_postcondition
              AE2P.allInstances->includesAll(Set{ae2p1}) and
              (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
                (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
                  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                    (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con2|
                      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                        theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                        theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                        theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                        theActivityEdgeC.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con2}) and
                        theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                        theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                        condition2.cp_Condition_AE2CON->includesAll(Set{ae2con2}) and
                        condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
                        theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                        theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
                        ae2p3.p.name=ae2p3.ae.name and
                        ae2con1.con.expression=ae2con1.ae.guard and
                        ae2p2.p.name=ae2p2.ae.name and
                        ae2con2.con.expression=ae2con2.ae.guard and
                        ae2p4.p.name=ae2p4.ae.name
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoFinalNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,finalNode:FinalNode),
  matchCL:Tuple(ae2p:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoFinalNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(finalNode:FinalNode,theActivityEdgeA:ActivityEdge)
  let finalNode:FinalNode = matchSR.finalNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    finalNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    finalNode.cp_FinalNode_F2P->size()=0 and
    --T_precondition and
    --C_precondition
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and    
    ae2p.p.name=ae2p.ae.name

post trafoFinalNode_forwTrafo_post:
--------------------
--matchSR : Tuple(finalNode:FinalNode,theActivityEdgeA:ActivityEdge)
  let finalNode:FinalNode = matchSR.finalNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
    (Process.allInstances - Process.allInstances@pre)->exists(SKIP|
      SKIP.process->includesAll(Set{assignment}) and
      assignment.left->includesAll(Set{theProcessA}) and
      SKIP.name = 'SKIP' and
      --C_postcondition
      AE2P.allInstances->includesAll(Set{ae2p}) and
      (F2P.allInstances - F2P.allInstances@pre)->exists(f2p|
        SKIP.cp_Process_F2P->includesAll(Set{f2p}) and
        finalNode.cp_FinalNode_F2P->includesAll(Set{f2p})
      )
    )
  )

context RuleCollection::trafoForkNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,forkNode:ForkNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTL:Tuple(theProcessA:Process))

pre trafoForkNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(forkNode:ForkNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let forkNode:ForkNode = matchSR.forkNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
    --S_precondition
    forkNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeD.name<>oclUndefined(String) and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoForkNode_forwTrafo_post:
--------------------
--matchSR : Tuple(forkNode:ForkNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let forkNode:ForkNode = matchSR.forkNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTL : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTL.theProcessA in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment|
    (Concurrency.allInstances - Concurrency.allInstances@pre)->exists(concurrency1|
      (Concurrency.allInstances - Concurrency.allInstances@pre)->exists(concurrency2|
        (Process.allInstances - Process.allInstances@pre)->exists(theProcessB|
          (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
            (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
              assignment.left->includesAll(Set{theProcessA}) and
              concurrency1.process->includesAll(Set{assignment}) and
              concurrency1.leftHandSide->includesAll(Set{theProcessB}) and
              concurrency1.rightHandSide->includesAll(Set{concurrency2}) and
              concurrency2.leftHandSide->includesAll(Set{theProcessC}) and
              concurrency2.rightHandSide->includesAll(Set{theProcessD}) and
              --C_postcondition
              AE2P.allInstances->includesAll(Set{ae2p1}) and
              (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
                (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
                  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                    theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
                    theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                    theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
                    theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
                    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
                    ae2p3.p.name=ae2p3.ae.name and
                    ae2p2.p.name=ae2p2.ae.name and
                    ae2p4.p.name=ae2p4.ae.name
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoInitialNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,init:InitialNode))

pre trafoInitialNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(init:InitialNode,theActivityEdgeA:ActivityEdge)
  let init:InitialNode = matchSR.init in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
    --S_precondition
    init.outEdge->includesAll(Set{theActivityEdgeA}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->size()=0
    --T_precondition
    --C_precondition    

post trafoInitialNode_forwTrafo_post:
--------------------
--matchSR : Tuple(init:InitialNode,theActivityEdgeA:ActivityEdge)
  let init:InitialNode = matchSR.init in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  --T_postcondition
  (Process.allInstances - Process.allInstances@pre)->exists(theProcessA|
    --C_postcondition
    (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p|
      theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
      theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and
      ae2p.p.name=ae2p.ae.name
    )
  )

context RuleCollection::trafoJoinNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,joinNode:JoinNode,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
  matchTL:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process))

pre trafoJoinNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(joinNode:JoinNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let joinNode:JoinNode = matchSR.joinNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  let theProcessC:Process = matchTL.theProcessC in
    --S_precondition
    joinNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    joinNode.inEdge->includesAll(Set{theActivityEdgeB}) and
    joinNode.inEdge->includesAll(Set{theActivityEdgeC}) and
    joinNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String)  and
    theActivityEdgeD.name<>oclUndefined(String) and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p3.p.name=ae2p3.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoJoinNode_forwTrafo_post:
--------------------
--matchSR : Tuple(joinNode:JoinNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let joinNode:JoinNode = matchSR.joinNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  let theProcessC:Process = matchTL.theProcessC in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA,theProcessB,theProcessC}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment1|
    (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment2|
      (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment3|
        (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix1|
          (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix2|
            (Prefix.allInstances - Prefix.allInstances@pre)->exists(prefix3|
              (Event.allInstances - Event.allInstances@pre)->exists(processJoin|
                (Process.allInstances - Process.allInstances@pre)->exists(SKIP|
                  (Process.allInstances - Process.allInstances@pre)->exists(theProcessD|
                    assignment1.left->includesAll(Set{theProcessA}) and
                    prefix1.process->includesAll(Set{assignment1}) and
                    assignment2.left->includesAll(Set{theProcessB}) and
                    prefix2.process->includesAll(Set{assignment2}) and
                    assignment3.left->includesAll(Set{theProcessC}) and
                    prefix3.process->includesAll(Set{assignment3}) and
                    processJoin.prefix->includesAll(Set{prefix1}) and
                    theProcessD.prefix->includesAll(Set{prefix1}) and
                    processJoin.prefix->includesAll(Set{prefix2}) and
                    SKIP.prefix->includesAll(Set{prefix2}) and
                    processJoin.prefix->includesAll(Set{prefix3}) and
                    SKIP.prefix->includesAll(Set{prefix3}) and
                    SKIP.name='SKIP' and
                    processJoin.name='processJoin' and
                    --C_postcondition
                    AE2P.allInstances->includesAll(Set{ae2p1,ae2p3,ae2p2}) and
                    (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
                      theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
                      theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
                      ae2p4.p.name=ae2p4.ae.name
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

context RuleCollection::trafoMergeNode_forwTrafo(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,mergeNode:MergeNode),
  matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
  matchTL:Tuple(theProcessA:Process,theProcessB:Process))

pre trafoMergeNode_forwTrafo_pre:
--------------------
--matchSR : Tuple(mergeNode:MergeNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let mergeNode:MergeNode = matchSR.mergeNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
    --S_precondition
    mergeNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    mergeNode.inEdge->includesAll(Set{theActivityEdgeB}) and
    mergeNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String)  and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoMergeNode_forwTrafo_post:
--------------------
--matchSR : Tuple(mergeNode:MergeNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let mergeNode:MergeNode = matchSR.mergeNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTL : Tuple(theProcessA:Process,theProcessB:Process)
  let theProcessA:Process = matchTL.theProcessA in
  let theProcessB:Process = matchTL.theProcessB in
  --T_postcondition
  Process.allInstances->includesAll(Set{theProcessA,theProcessB}) and
  (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment1|
    (ProcessAssignment.allInstances - ProcessAssignment.allInstances@pre)->exists(assignment2|
      (Process.allInstances - Process.allInstances@pre)->exists(theProcessC|
        assignment1.left->includesAll(Set{theProcessA}) and
        theProcessC.process->includesAll(Set{assignment1}) and
        assignment2.left->includesAll(Set{theProcessB}) and
        theProcessC.process->includesAll(Set{assignment2}) and
        --C_postcondition
        AE2P.allInstances->includesAll(Set{ae2p1,ae2p2}) and
        (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
          theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
          theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
          ae2p3.p.name=ae2p3.ae.name
        )
      )
    )
  )

--------------------------------------------------Integration

context RuleCollection::trafoActionNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,action:Action,theActivityEdgeB:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,prefix:Prefix,theProcessB:Process,theEvent:Event))

pre trafoActionNode_integration_pre:
--------------------
--matchSR : Tuple(action:Action,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let action:Action = matchSR.action in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,prefix:Prefix,theEvent:Event,theProcessA:Process,theProcessB:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let prefix:Prefix = matchTR.prefix in
  let theEvent:Event = matchTR.theEvent in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
    --S_precondition
    action.inEdge->includesAll(Set{theActivityEdgeA}) and
    action.outEdge->includesAll(Set{theActivityEdgeB}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    action.name<>oclUndefined(String) and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    action.cp_Action_AC2E->size()=0 and
    --T_precondition
    assignment.left->includesAll(Set{theProcessA}) and
    prefix.process->includesAll(Set{assignment}) and
    theEvent.prefix->includesAll(Set{prefix}) and
    theProcessB.prefix->includesAll(Set{prefix}) and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoActionNode_integration_post:
--------------------
--matchSR : Tuple(action:Action,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge)
  let action:Action = matchSR.action in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,prefix:Prefix,theEvent:Event,theProcessA:Process,theProcessB:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let prefix:Prefix = matchTR.prefix in
  let theEvent:Event = matchTR.theEvent in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1}) and
  (AC2E.allInstances - AC2E.allInstances@pre)->exists(ac2e|
    (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
      theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
      theEvent.cp_Event_AC2E->includesAll(Set{ac2e}) and
      action.cp_Action_AC2E->includesAll(Set{ac2e}) and
      theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
      ac2e.event.name=ac2e.act.name and
      ae2p2.p.name=ae2p2.ae.name
    )
  )

context RuleCollection::trafoDecision2Node_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,condition1:Condition,theProcessB:Process,theProcessC:Process))

pre trafoDecision2Node_integration_pre:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,condition1:Condition,theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let condition1:Condition = matchTR.condition1 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
    --S_precondition
    decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.guard = 'else' and
    decisionNode.outEdge->size()=2 and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition
    assignment.left->includesAll(Set{theProcessA}) and
    condition1.process->includesAll(Set{assignment}) and
    condition1.leftHandSide->includesAll(Set{theProcessB}) and
    condition1.rightHandSide->includesAll(Set{theProcessC}) and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision2Node_integration_post:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,condition1:Condition,theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let condition1:Condition = matchTR.condition1 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1}) and
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
    (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
        theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
        theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
        theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
        condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
        theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
        theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
        ae2p3.p.name=ae2p3.ae.name and
        ae2con1.con.expression=ae2con1.ae.guard and
        ae2p2.p.name=ae2p2.ae.name
      )
    )
  )

context RuleCollection::trafoDecision3Node_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,decisionNode:DecisionNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,condition1:Condition,condition2:Condition,theProcessB:Process,theProcessC:Process,theProcessD:Process))

pre trafoDecision3Node_integration_pre:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,condition1:Condition,condition2:Condition,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let condition1:Condition = matchTR.condition1 in
  let condition2:Condition = matchTR.condition2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
    --S_precondition
    decisionNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    decisionNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeD.guard = 'else' and
    decisionNode.outEdge->size()=3 and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition
    assignment.left->includesAll(Set{theProcessA}) and
    condition1.process->includesAll(Set{assignment}) and
    condition1.leftHandSide->includesAll(Set{theProcessB}) and
    condition1.rightHandSide->includesAll(Set{condition2}) and
    condition2.leftHandSide->includesAll(Set{theProcessC}) and
    condition2.rightHandSide->includesAll(Set{theProcessD}) and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoDecision3Node_integration_post:
--------------------
--matchSR : Tuple(decisionNode:DecisionNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let decisionNode:DecisionNode = matchSR.decisionNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,condition1:Condition,condition2:Condition,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let condition1:Condition = matchTR.condition1 in
  let condition2:Condition = matchTR.condition2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1}) and
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
    (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con1|
      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
        (AE2CON.allInstances - AE2CON.allInstances@pre)->exists(ae2con2|
          (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
            theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
            theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
            theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
            theActivityEdgeC.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con2}) and
            theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
            theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
            condition2.cp_Condition_AE2CON->includesAll(Set{ae2con2}) and
            condition1.cp_Condition_AE2CON->includesAll(Set{ae2con1}) and
            theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
            theActivityEdgeB.cp_ActivityEdge_AE2CON->includesAll(Set{ae2con1}) and
            ae2p3.p.name=ae2p3.ae.name and
            ae2con1.con.expression=ae2con1.ae.guard and
            ae2p2.p.name=ae2p2.ae.name and
            ae2con2.con.expression=ae2con2.ae.guard and
            ae2p4.p.name=ae2p4.ae.name
          )
        )
      )
    )
  )

context RuleCollection::trafoFinalNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,finalNode:FinalNode),
  matchCL:Tuple(ae2p:AE2P),
  matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,SKIP:Process))

pre trafoFinalNode_integration_pre:
--------------------
--matchSR : Tuple(finalNode:FinalNode,theActivityEdgeA:ActivityEdge)
  let finalNode:FinalNode = matchSR.finalNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTR : Tuple(SKIP:Process,assignment:ProcessAssignment,theProcessA:Process)
  let SKIP:Process = matchTR.SKIP in
  let assignment:ProcessAssignment = matchTR.assignment in
  let theProcessA:Process = matchTR.theProcessA in
    --S_precondition
    finalNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    finalNode.cp_FinalNode_F2P->size()=0 and
    --T_precondition
    SKIP.process->includesAll(Set{assignment}) and
    assignment.left->includesAll(Set{theProcessA}) and
    SKIP.name = 'SKIP' and
    --C_precondition
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and    
    ae2p.p.name=ae2p.ae.name

post trafoFinalNode_integration_post:
--------------------
--matchSR : Tuple(finalNode:FinalNode,theActivityEdgeA:ActivityEdge)
  let finalNode:FinalNode = matchSR.finalNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchCL : Tuple(ae2p:AE2P)
  let ae2p:AE2P = matchCL.ae2p in
--------------------
--matchTR : Tuple(SKIP:Process,assignment:ProcessAssignment,theProcessA:Process)
  let SKIP:Process = matchTR.SKIP in
  let assignment:ProcessAssignment = matchTR.assignment in
  let theProcessA:Process = matchTR.theProcessA in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p}) and
  (F2P.allInstances - F2P.allInstances@pre)->exists(f2p|
    SKIP.cp_Process_F2P->includesAll(Set{f2p}) and
    finalNode.cp_FinalNode_F2P->includesAll(Set{f2p})
  )

context RuleCollection::trafoForkNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,forkNode:ForkNode,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P),
  matchTR:Tuple(theProcessA:Process,assignment:ProcessAssignment,concurrency1:Concurrency,concurrency2:Concurrency,theProcessB:Process,theProcessC:Process,theProcessD:Process))

pre trafoForkNode_integration_pre:
--------------------
--matchSR : Tuple(forkNode:ForkNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let forkNode:ForkNode = matchSR.forkNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,concurrency1:Concurrency,concurrency2:Concurrency,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let concurrency1:Concurrency = matchTR.concurrency1 in
  let concurrency2:Concurrency = matchTR.concurrency2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
    --S_precondition
    forkNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeB}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    forkNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String)  and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeD.name<>oclUndefined(String) and
    theActivityEdgeB.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition
    assignment.left->includesAll(Set{theProcessA}) and
    concurrency1.process->includesAll(Set{assignment}) and
    concurrency1.leftHandSide->includesAll(Set{theProcessB}) and
    concurrency1.rightHandSide->includesAll(Set{concurrency2}) and
    concurrency2.leftHandSide->includesAll(Set{theProcessC}) and
    concurrency2.rightHandSide->includesAll(Set{theProcessD}) and
    --C_precondition
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name

post trafoForkNode_integration_post:
--------------------
--matchSR : Tuple(forkNode:ForkNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let forkNode:ForkNode = matchSR.forkNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
--------------------
--matchTR : Tuple(assignment:ProcessAssignment,concurrency1:Concurrency,concurrency2:Concurrency,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let assignment:ProcessAssignment = matchTR.assignment in
  let concurrency1:Concurrency = matchTR.concurrency1 in
  let concurrency2:Concurrency = matchTR.concurrency2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1}) and
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
    (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p2|
      (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
        theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
        theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
        theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
        theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
        theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
        theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
        ae2p3.p.name=ae2p3.ae.name and
        ae2p2.p.name=ae2p2.ae.name and
        ae2p4.p.name=ae2p4.ae.name
      )
    )
  )

context RuleCollection::trafoInitialNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,init:InitialNode),
  matchTR:Tuple(theProcessA:Process))

pre trafoInitialNode_integration_pre:
--------------------
--matchSR : Tuple(init:InitialNode,theActivityEdgeA:ActivityEdge)
  let init:InitialNode = matchSR.init in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchTR : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTR.theProcessA in
    --S_precondition
    init.outEdge->includesAll(Set{theActivityEdgeA}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->size()=0
    --T_precondition
    --C_precondition    

post trafoInitialNode_integration_post:
--------------------
--matchSR : Tuple(init:InitialNode,theActivityEdgeA:ActivityEdge)
  let init:InitialNode = matchSR.init in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
--------------------
--matchTR : Tuple(theProcessA:Process)
  let theProcessA:Process = matchTR.theProcessA in
  --C_postcondition
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p|
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p}) and
    ae2p.p.name=ae2p.ae.name
  )

context RuleCollection::trafoJoinNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,joinNode:JoinNode,theActivityEdgeD:ActivityEdge),
  matchCL:Tuple(ae2p1:AE2P,ae2p3:AE2P,ae2p2:AE2P),
  matchTR:Tuple(theProcessA:Process,theProcessB:Process,theProcessC:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,assignment3:ProcessAssignment,prefix1:Prefix,prefix2:Prefix,prefix3:Prefix,processJoin:Event,SKIP:Process,theProcessD:Process))

pre trafoJoinNode_integration_pre:
--------------------
--matchSR : Tuple(joinNode:JoinNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let joinNode:JoinNode = matchSR.joinNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTR : Tuple(SKIP:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,assignment3:ProcessAssignment,prefix1:Prefix,prefix2:Prefix,prefix3:Prefix,processJoin:Event,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let SKIP:Process = matchTR.SKIP in
  let assignment1:ProcessAssignment = matchTR.assignment1 in
  let assignment2:ProcessAssignment = matchTR.assignment2 in
  let assignment3:ProcessAssignment = matchTR.assignment3 in
  let prefix1:Prefix = matchTR.prefix1 in
  let prefix2:Prefix = matchTR.prefix2 in
  let prefix3:Prefix = matchTR.prefix3 in
  let processJoin:Event = matchTR.processJoin in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
    --S_precondition
    joinNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    joinNode.inEdge->includesAll(Set{theActivityEdgeB}) and
    joinNode.inEdge->includesAll(Set{theActivityEdgeC}) and
    joinNode.outEdge->includesAll(Set{theActivityEdgeD}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String) and
    theActivityEdgeC.name<>oclUndefined(String)  and
    theActivityEdgeD.name<>oclUndefined(String) and
    theActivityEdgeD.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition
    assignment1.left->includesAll(Set{theProcessA}) and
    prefix1.process->includesAll(Set{assignment1}) and
    assignment2.left->includesAll(Set{theProcessB}) and
    prefix2.process->includesAll(Set{assignment2}) and
    assignment3.left->includesAll(Set{theProcessC}) and
    prefix3.process->includesAll(Set{assignment3}) and
    processJoin.prefix->includesAll(Set{prefix1}) and
    theProcessD.prefix->includesAll(Set{prefix1}) and
    processJoin.prefix->includesAll(Set{prefix2}) and
    SKIP.prefix->includesAll(Set{prefix2}) and
    processJoin.prefix->includesAll(Set{prefix3}) and
    SKIP.prefix->includesAll(Set{prefix3}) and
    SKIP.name='SKIP' and
    processJoin.name='processJoin' and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p3.p.name=ae2p3.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoJoinNode_integration_post:
--------------------
--matchSR : Tuple(joinNode:JoinNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,theActivityEdgeD:ActivityEdge)
  let joinNode:JoinNode = matchSR.joinNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
  let theActivityEdgeD:ActivityEdge = matchSR.theActivityEdgeD in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P,ae2p3:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
  let ae2p3:AE2P = matchCL.ae2p3 in
--------------------
--matchTR : Tuple(SKIP:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,assignment3:ProcessAssignment,prefix1:Prefix,prefix2:Prefix,prefix3:Prefix,processJoin:Event,theProcessA:Process,theProcessB:Process,theProcessC:Process,theProcessD:Process)
  let SKIP:Process = matchTR.SKIP in
  let assignment1:ProcessAssignment = matchTR.assignment1 in
  let assignment2:ProcessAssignment = matchTR.assignment2 in
  let assignment3:ProcessAssignment = matchTR.assignment3 in
  let prefix1:Prefix = matchTR.prefix1 in
  let prefix2:Prefix = matchTR.prefix2 in
  let prefix3:Prefix = matchTR.prefix3 in
  let processJoin:Event = matchTR.processJoin in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  let theProcessD:Process = matchTR.theProcessD in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1,ae2p3,ae2p2}) and
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p4|
    theActivityEdgeD.cp_ActivityEdge_AE2P->includesAll(Set{ae2p4}) and
    theProcessD.cp_Process_AE2P->includesAll(Set{ae2p4}) and
    ae2p4.p.name=ae2p4.ae.name
  )

context RuleCollection::trafoMergeNode_integration(
  matchSR:Tuple(theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge,mergeNode:MergeNode),
  matchCL:Tuple(ae2p1:AE2P,ae2p2:AE2P),
  matchTR:Tuple(theProcessA:Process,theProcessB:Process,assignment1:ProcessAssignment,assignment2:ProcessAssignment,theProcessC:Process))

pre trafoMergeNode_integration_pre:
--------------------
--matchSR : Tuple(mergeNode:MergeNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let mergeNode:MergeNode = matchSR.mergeNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTR : Tuple(assignment1:ProcessAssignment,assignment2:ProcessAssignment,theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let assignment1:ProcessAssignment = matchTR.assignment1 in
  let assignment2:ProcessAssignment = matchTR.assignment2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
    --S_precondition
    mergeNode.inEdge->includesAll(Set{theActivityEdgeA}) and
    mergeNode.inEdge->includesAll(Set{theActivityEdgeB}) and
    mergeNode.outEdge->includesAll(Set{theActivityEdgeC}) and
    theActivityEdgeA.name<>oclUndefined(String) and
    theActivityEdgeB.name<>oclUndefined(String)  and
    theActivityEdgeC.name<>oclUndefined(String) and
    theActivityEdgeC.cp_ActivityEdge_AE2P->size()=0 and
    --T_precondition
    assignment1.left->includesAll(Set{theProcessA}) and
    theProcessC.process->includesAll(Set{assignment1}) and
    assignment2.left->includesAll(Set{theProcessB}) and
    theProcessC.process->includesAll(Set{assignment2}) and
    --C_precondition
    theActivityEdgeB.cp_ActivityEdge_AE2P->includesAll(Set{ae2p2}) and
    theProcessA.cp_Process_AE2P->includesAll(Set{ae2p1}) and
    theProcessB.cp_Process_AE2P->includesAll(Set{ae2p2}) and
    theActivityEdgeA.cp_ActivityEdge_AE2P->includesAll(Set{ae2p1}) and    
    ae2p1.p.name=ae2p1.ae.name and
    ae2p2.p.name=ae2p2.ae.name

post trafoMergeNode_integration_post:
--------------------
--matchSR : Tuple(mergeNode:MergeNode,theActivityEdgeA:ActivityEdge,theActivityEdgeB:ActivityEdge,theActivityEdgeC:ActivityEdge)
  let mergeNode:MergeNode = matchSR.mergeNode in
  let theActivityEdgeA:ActivityEdge = matchSR.theActivityEdgeA in
  let theActivityEdgeB:ActivityEdge = matchSR.theActivityEdgeB in
  let theActivityEdgeC:ActivityEdge = matchSR.theActivityEdgeC in
--------------------
--matchCL : Tuple(ae2p1:AE2P,ae2p2:AE2P)
  let ae2p1:AE2P = matchCL.ae2p1 in
  let ae2p2:AE2P = matchCL.ae2p2 in
--------------------
--matchTR : Tuple(assignment1:ProcessAssignment,assignment2:ProcessAssignment,theProcessA:Process,theProcessB:Process,theProcessC:Process)
  let assignment1:ProcessAssignment = matchTR.assignment1 in
  let assignment2:ProcessAssignment = matchTR.assignment2 in
  let theProcessA:Process = matchTR.theProcessA in
  let theProcessB:Process = matchTR.theProcessB in
  let theProcessC:Process = matchTR.theProcessC in
  --C_postcondition
  AE2P.allInstances->includesAll(Set{ae2p1,ae2p2}) and
  (AE2P.allInstances - AE2P.allInstances@pre)->exists(ae2p3|
    theActivityEdgeC.cp_ActivityEdge_AE2P->includesAll(Set{ae2p3}) and
    theProcessC.cp_Process_AE2P->includesAll(Set{ae2p3}) and
    ae2p3.p.name=ae2p3.ae.name
  )
